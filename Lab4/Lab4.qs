// Quantum Software Development
// Lab 4: Quantum Communication
// Copyright 2023 The MITRE Corporation. All Rights Reserved.
//
// Due 3/1 at 6:00PM ET:
//  - Completed exercises and evidence of unit tests passing uploaded to GitHub.

namespace Lab4 {

    open Microsoft.Quantum.Canon;
    open Microsoft.Quantum.Convert;
    open Microsoft.Quantum.Intrinsic;
    open Microsoft.Quantum.Diagnostics;


    /// # Summary
    /// In this exercise, you will take on the role of the "sender" in the
    /// superdense coding protocol. You will encode a classical message into a
    /// pair of entangled qubits. The system has already entangled the two
    /// qubits together into the 1/√2(|00> + |11>) state and sent one of the
    /// qubits to the remote receiver. You are given a classical buffer with
    /// two bits in it, and the other remaining qubit. Your goal is to encode
    /// both of the classical bits into the entangled qubit pair using only
    /// single-qubit gates on the provided "sender" qubit.
    ///
    /// # Input
    /// ## buffer
    /// An array of two classical bits, where false represents 0, and true
    /// represents 1.
    ///
    /// ## pairA
    /// A qubit that is entangled with another qubit in the state
    /// 1/√2(|00> + |11>).
    operation Exercise1 (buffer : Bool[], pairA : Qubit) : Unit {
        // TODO
       if(buffer[0] == true){
        Z(pairA);
       }
       if(buffer[1] == true){
        X(pairA);
       }
    }


    /// # Summary
    /// In this exercise, you will take on the role of the "receiver" in the
    /// superdense coding protocol. The sender has sent a pair of entangled
    /// qubits to you and encoded two bits of classical data in them. The
    /// system has received the two qubits, and has presented them here for
    /// you to process. The state of the qubits is unknown, but it should be
    /// in one of the states that you created with your encoding operation
    /// above. Your goal is to recover the two classical bits that are encoded
    /// in the qubits, and return them in a classical buffer.
    ///
    /// # Input
    /// ## pairA
    /// One of the qubits in the entangled pair.
    ///
    /// ## pairB
    /// The other qubit in the entangled pair.
    ///
    /// # Output
    /// A classical bit array containing the two bits that were encoded in the
    /// entangled pair. Use false for 0 and true for 1.
    operation Exercise2 (pairA : Qubit, pairB : Qubit) : Bool[] {
        // TODO
        mutable result = [false, false];
        CNOT(pairA,pairB);
        H(pairA);
        if(M(pairA)== One){
           set result w/= 0 <- true;
        }
        if(M(pairB)== One){
            set result w/= 1 <- true; 
                   }
    return result;
    }


    /// # Summary
    /// In this exercise, you will take on the role of the first party in the
    /// BB84 protocol. (This is the QKD scheme discussed in lecture.) To make
    /// the operation easier to test, the random bits used in the protocol are
    /// given. Your goal is to encode A's public and secret bits into a qubit
    /// and determine whether the secret bit can be used or must be thrown away
    /// based on B's public bit.
    ///
    /// # Input
    /// ## aPublic
    /// The random bit you generated that will be shared with the other party.
    ///
    /// ## aSecret
    /// The random bit you generated that will not be shared directly with the
    /// other party, but may or may not be used as a shared secret based on the
    /// value of bPublic.
    ///
    /// ## bPublic
    /// The random bit generated by the other party and shared with you.
    ///
    /// ## qubit
    /// The qubit used to encode aPublic and aSecret.
    ///
    /// # Output
    /// A Boolean value that is true if the secret bit can be used and false if
    /// it must be thrown away.
    ///
    /// # Remarks
    /// In a real implementation of the protocol, bPublic would not be shared
    /// until after the qubit is measured.
    operation Exercise3 (
        aPublic : Bool,
        aSecret : Bool,
        bPublic : Bool,
        qubit: Qubit
    ) : Bool {
        // TODO
        if(aSecret){
            X(qubit);
        }
        if(aPublic){
            H(qubit);
        }

        if(aPublic == bPublic){
            return true;
        }
        else{
            return false;
        }
    }


    /// # Summary
    /// In this exercise, you will take on the role of the second party in the
    /// BB84 protocol. Your goal is to attempt to decode A's secret bit and
    /// determine whether the it can be used or must be thrown away based on
    /// A's public bit.
    ///
    /// # Input
    /// ## aPublic
    /// The random bit generated by the other party and shared with you.
    ///
    /// ## bPublic
    /// The random bit you generated that will be shared with the other party.
    ///
    /// ## qubit
    /// The qubit you will attempt to decode.
    ///
    /// # Output
    /// A tuple of two Boolean values. The first value is true or false based
    /// on whether the secret bit you decoded is a 1 or 0. The second value is
    /// true if the secret bit can be used and false if it must be thrown away.
    operation Exercise4 (
        aPublic : Bool,
        bPublic : Bool,
        qubit: Qubit
    ) : (Bool, Bool) {
        // TODO
        if(bPublic){
            H(qubit);
        }
        let bSecret = ResultAsBool(M(qubit));
        if(aPublic == bPublic){
            return (bSecret,true);
        }
        return(bSecret,false);
    }
}
